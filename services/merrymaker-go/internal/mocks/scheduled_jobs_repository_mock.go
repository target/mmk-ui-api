// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/target/mmk-ui-api/internal/core (interfaces: ScheduledJobsRepository)
//
// Generated by this command:
//
//	mockgen -package=mocks -destination=scheduled_jobs_repository_mock.go github.com/target/mmk-ui-api/internal/core ScheduledJobsRepository
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	sql "database/sql"
	reflect "reflect"
	time "time"

	domain "github.com/target/mmk-ui-api/internal/domain"
	gomock "go.uber.org/mock/gomock"
)

// MockScheduledJobsRepository is a mock of ScheduledJobsRepository interface.
type MockScheduledJobsRepository struct {
	ctrl     *gomock.Controller
	recorder *MockScheduledJobsRepositoryMockRecorder
	isgomock struct{}
}

// MockScheduledJobsRepositoryMockRecorder is the mock recorder for MockScheduledJobsRepository.
type MockScheduledJobsRepositoryMockRecorder struct {
	mock *MockScheduledJobsRepository
}

// NewMockScheduledJobsRepository creates a new mock instance.
func NewMockScheduledJobsRepository(ctrl *gomock.Controller) *MockScheduledJobsRepository {
	mock := &MockScheduledJobsRepository{ctrl: ctrl}
	mock.recorder = &MockScheduledJobsRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockScheduledJobsRepository) EXPECT() *MockScheduledJobsRepositoryMockRecorder {
	return m.recorder
}

// FindDue mocks base method.
func (m *MockScheduledJobsRepository) FindDue(ctx context.Context, now time.Time, limit int) ([]domain.ScheduledTask, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindDue", ctx, now, limit)
	ret0, _ := ret[0].([]domain.ScheduledTask)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindDue indicates an expected call of FindDue.
func (mr *MockScheduledJobsRepositoryMockRecorder) FindDue(ctx, now, limit any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindDue", reflect.TypeOf((*MockScheduledJobsRepository)(nil).FindDue), ctx, now, limit)
}

// FindDueTx mocks base method.
func (m *MockScheduledJobsRepository) FindDueTx(ctx context.Context, tx *sql.Tx, p domain.FindDueParams) ([]domain.ScheduledTask, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindDueTx", ctx, tx, p)
	ret0, _ := ret[0].([]domain.ScheduledTask)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindDueTx indicates an expected call of FindDueTx.
func (mr *MockScheduledJobsRepositoryMockRecorder) FindDueTx(ctx, tx, p any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindDueTx", reflect.TypeOf((*MockScheduledJobsRepository)(nil).FindDueTx), ctx, tx, p)
}

// MarkQueued mocks base method.
func (m *MockScheduledJobsRepository) MarkQueued(ctx context.Context, id string, now time.Time) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MarkQueued", ctx, id, now)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// MarkQueued indicates an expected call of MarkQueued.
func (mr *MockScheduledJobsRepositoryMockRecorder) MarkQueued(ctx, id, now any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MarkQueued", reflect.TypeOf((*MockScheduledJobsRepository)(nil).MarkQueued), ctx, id, now)
}

// MarkQueuedTx mocks base method.
func (m *MockScheduledJobsRepository) MarkQueuedTx(ctx context.Context, tx *sql.Tx, p domain.MarkQueuedParams) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MarkQueuedTx", ctx, tx, p)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// MarkQueuedTx indicates an expected call of MarkQueuedTx.
func (mr *MockScheduledJobsRepositoryMockRecorder) MarkQueuedTx(ctx, tx, p any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MarkQueuedTx", reflect.TypeOf((*MockScheduledJobsRepository)(nil).MarkQueuedTx), ctx, tx, p)
}

// UpdateActiveFireKeyTx mocks base method.
func (m *MockScheduledJobsRepository) UpdateActiveFireKeyTx(ctx context.Context, tx *sql.Tx, p domain.UpdateActiveFireKeyParams) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateActiveFireKeyTx", ctx, tx, p)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateActiveFireKeyTx indicates an expected call of UpdateActiveFireKeyTx.
func (mr *MockScheduledJobsRepositoryMockRecorder) UpdateActiveFireKeyTx(ctx, tx, p any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateActiveFireKeyTx", reflect.TypeOf((*MockScheduledJobsRepository)(nil).UpdateActiveFireKeyTx), ctx, tx, p)
}

// TryWithTaskLock mocks base method.
func (m *MockScheduledJobsRepository) TryWithTaskLock(ctx context.Context, taskName string, fn func(context.Context, *sql.Tx) error) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TryWithTaskLock", ctx, taskName, fn)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// TryWithTaskLock indicates an expected call of TryWithTaskLock.
func (mr *MockScheduledJobsRepositoryMockRecorder) TryWithTaskLock(ctx, taskName, fn any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TryWithTaskLock", reflect.TypeOf((*MockScheduledJobsRepository)(nil).TryWithTaskLock), ctx, taskName, fn)
}
